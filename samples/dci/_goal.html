<script>
"use strict";

var isNodeJs = (typeof window == 'undefined' && typeof global != 'undefined');
var globalNamespace = isNodeJs ? global: window;

var DCI = {};

//This function is for handling calls beginning with `this`; it calls a method on the current role player,
//which could be either a role method or a method on the data object.
//
// TODO test data object methods that aren't overridden by the role
//
DCI.callMethodOnSelf = function callMethodOnSelf(context, player, roleName, methodName, args) {
	//if `this` is not equal to the current role player
	if (player != context[roleName]) {
		//support functions within role methods for which `this` is unbound - but make sure we
		//don't wrongly assume `this` refers to the current role 
		if (player != undefined && player != globalNamespace) {
			//not a role method; call normally
			return player[methodName].apply(player, args);
		}
		//if we're here, then `this` probably *should* refer to the current role and the only
		//reason it's undefined is most likely a nested function
		//(e.g. a callback function passed to forEach() to loop over an array)
		else {
			player = context[roleName];
		}
	}

	var roleMethod = context['__$'+roleName][methodName];
	//if the method exists on the role, we always call it (role methods override data object methods)
	if (typeof roleMethod == 'function') {
		return (args ? roleMethod.apply(player, args): roleMethod.call(player));
	}
	//otherwise, call the data object method
	//(if the method is not found on the data object, this will throw Javascript's usual
	//'[function name] is not defined' error)
	return player[methodName].apply(player, args);
}

globalNamespace.DCI = DCI;

//Compiled by TS
DCI.Context = function Context(callback) {
	return function () {
		var args = [];
		for (var _i = 0; _i < (arguments.length - 0); _i++) {
			args[_i] = arguments[_i + 0];
		}
		var context = new callback();
		context.bindRoles.apply(callback, arguments);
		return context;
	};
};


//for class version

function TransferMoney(sourceAcct, destinationAcct) {
	var __context = this;
	this.bindRoles(sourceAcct, destinationAcct);
	
	//roles need to be inside constructor so that __context variable can be accessed
	this.__$SourceAccount = {
		transferOut: function () {
            //this.withdraw();
            __context.__$DestinationAccount.deposit.call(__context.__rolePlayers['DestinationAccount']);
        },
        withdraw: function () {
        }
	}
}

TransferMoney.prototype.bindRoles = function(sourceAcct, destinationAcct) {
	__context.SourceAccount = sourceAcct;
	__context.DestinationAccount = destinationAcct;
}

TransferMoney.prototype.execute = function() {
	var __context = this;
	__context.__$SourceAccount.transferOut.call(__context.SourceAccount);
};

//for JS version

function TransferMoney(sourceAcct, destinationAcct) {
var __context = this;
__context.__rolePlayers = {};
    this.bindRoles = function () {
        __context.__rolePlayers['SourceAccount'] = sourceAcct;
        __context.__rolePlayers['DestinationAccount'] = destinationAcct;
    };
    this.bindRoles();
    this.execute = function () {
        __context.__$SourceAccount.transferOut.call(__context.__rolePlayers['SourceAccount']);
    };
    this.__$SourceAccount = {        transferOut: function () {
            //this.withdraw();
            __context.__$DestinationAccount.deposit.call(__context.__rolePlayers['DestinationAccount']);
        }
        ,withdraw: function () {
        }
}
    this.__$DestinationAccount = {        deposit: function () {
            console.log('deposit');
        }
}
}
var ctx = new TransferMoney({}, {});
ctx.execute();


/*
function TransferMoney(sourceAcct) {
	var __context = this;
	
	this.__rolePlayers = {
		'SourceAccount': sourceAcct
	};

    this.__$SourceAccount = {
    	greet: function () {
            console.log("greetings!");
            this.increaseBalance();
        }

      , foo: function () {
            console.log('foo');
            //this.greet();            
            callRolePlayerMethod(__context, this, 'SourceAccount', 'greet');
            
//             [1,2,3].forEach(function() {
//             	callRolePlayerMethod(__context, this, 'SourceAccount', 'SourceAccount', 'greet');
//             });
        }
	}
	
	this.execute = function() {
		this.__$SourceAccount.foo.call(sourceAcct);
	}
}

var sourceAcct = {
	increaseBalance: function() {
		console.log('increaseBalance');
	}
};
var transferMoneyCtx = new TransferMoney(sourceAcct);
transferMoneyCtx.execute();
*/


</script>